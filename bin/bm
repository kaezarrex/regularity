#! /usr/bin/env python

from datetime import datetime, timedelta
import logging
import math
import re

def offset_minute(offset):
    '''Parse an offset string to see if it describes a minute offset.

       @param offset : str
           the offset string'''

    match = re.match(r'^([-+])([0-5]?[0-9])$', offset)

    if match:
        sign = match.group(1)
        minutes = int(match.group(2))

        seconds = 60 * minutes

        if '+' == sign:
            return seconds
        return -seconds

    return None

def offset_hour_minute(offset):
    '''Parse an offset string to see if it describes a hour:minute offset.

       @param offset : str
           the offset string'''

    match = re.match(r'^([-+])([0-9]+):([0-5][0-9])$', offset)

    if match:
        sign = match.group(1)
        hours = int(match.group(2))
        minutes = int(match.group(3))

        seconds = 60 * minutes

        if hours:
            hours = int(hours)
            seconds += 3600 * hours

        if '+' == sign:
            return seconds
        return -seconds

    return None

def parse_offset(offset):
    '''Parse a string intended to define an offset from now.

       @param offset : str
           the offset from now'''

    seconds = offset_minute(offset)
    if not seconds:
        seconds = offset_hour_minute(offset)

    if seconds:
        delta_time = timedelta(seconds=seconds)
        return datetime.utcnow() + delta_time

    return None

def parse_time_of_day(time):
    '''Parse a string intended to define a time of day, in 24 hour format

       @time : str
           the time of day'''

    match = re.match(r'(2[0-3]|[0-1][0-9]):([0-5][0-9])$', time)
    if match:
        hours = match.group(1)
        minutes = match.group(2)

        time = datetime.now()
        time = time.replace(microsecond=0)

        if hours is not None:
            hours = int(hours)
            time = time.replace(hour=hours)

        if minutes is not None:
            minutes = int(minutes)
            time = time.replace(minute=minutes)

        time = time.replace(second=0, microsecond=0)

        utc_offset = datetime.utcnow() - datetime.now()
        return time + utc_offset

    return None

def parse_time(time):
    '''Parse a string intended to define a time. It can be specified as an
       offset from now, or a time for TODAY. Offsets are defined as a + or -, 
       then a minute or hour:minute time string. If is no + or -, then the 
       string is parsed as a time. Times are specified as either hour:minute 
       or hour:minute:second strings.

       @param time : str
           a string representing an offset or time of day'''

    time = time.strip()

    _time = parse_offset(time)
    if _time:
        return _time

    _time = parse_time_of_day(time)
    if _time:
        return _time

    raise argparse.ArgumentTypeError('invalid time format')

def pang(model, args):
    '''Log or record a pang - something that happened at a certain point in
       time.
      
       @param model : reularity.model.Model
           the connection to mongoDB
       @param args : argparse.Namespace
           the parsed command line options'''

    timeline = 'bm.pang'
    if args.time:
        time = args.time
    else:
        time = datetime.utcnow()

    model.log(timeline, args.activity, start=args.time, end=args.time)

def session(model, args):
    '''Log or record an activity that happened over a range of time.
      
       @param model : reularity.model.Model
           the connection to mongoDB
       @param args : argparse.Namespace
           the parsed command line options'''

    timeline = 'bm.session'
    now = datetime.utcnow()

    if args.time1:
        if args.time2:
            start = min(args.time1, args.time2)
            end = max(args.time1, args.time2)
        else:
            start = min(now, args.time1)
            end = max(now, args.time1)

        model.log(timeline, args.activity, start=start, end=end)
    else:
        running = True

        model.log(timeline, args.activity, start=now)
        while running:
            try:
                model.update(timeline, args.activity)
                time.sleep(args.frequency)
            except KeyboardInterrupt:
                model.update(timeline, args.activity)
                running = False

def discretize(data, levels):
    '''Discretizes a list of values to a list of levels.

       @param levels : int
           the number of levels to discretize to'''

    min_ = float(min(data))
    max_ = float(max(data))
    increment = (max_ - min_) / levels

    thresholds = tuple(min_ + i * increment for i in xrange(1, levels)) + (max_,)

    def level(x):
        for i, threshold in enumerate(thresholds):
            if x <= threshold:
                return i
        return levels - 1

    return tuple(level(d) for d in data)

def stats(model, args):
    '''Print out statistics for the query defined by the command line
       parameters.

       @param model : reularity.model.Model
           the connection to mongoDB
       @param args : argparse.Namespace
           the parsed command line options'''

    events = model.events(
        name=args.activities,
        timeline=args.timelines
    )

    # TODO refactor this code

    if not events:
        print 'no events found'
        return

    N = len(events)
    print '%d events total' % N

    timedeltas = tuple(e['end'] - e['start'] for e in events)
    durations = tuple(td.total_seconds() for td in timedeltas)
    
    average = sum(durations) / N

    squared_differences = list((d - average)**2 for d in durations)
    standard_deviation = math.sqrt(sum(squared_differences) / N)

    times_per_hour = [0] * 24
    percent_of_hour = [0] * 24
    for e in events:
        start_hour = e['start'].hour
        end_hour = e['end'].hour

        for i in range(start_hour, end_hour+1):
            times_per_hour[i] += 1


    markers = (0x2581, 0x2582, 0x2583, 0x2584, 0x2585, 0x2586, 0x2587,)
    levels = discretize(times_per_hour, len(markers))
    times_per_hour_string = (unichr(markers[l]) for l in levels)
    times_per_hour_string = ' '.join(times_per_hour_string)


    print 'min duration (seconds):     %0.2f' % min(durations)
    print 'max duration (seconds):     %0.2f' % max(durations)
    print 'average duration (seconds): %0.2f +/- %0.2f' % (average, standard_deviation) 
    print 'times per hour:             %s' % times_per_hour_string
    print
    

if __name__ == "__main__":

    import argparse
    from itertools import compress
    import time

    import sys

    from regularity.model import Model

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    pang_parser = subparsers.add_parser('pang')
    pang_parser.add_argument('activity')
    pang_parser.add_argument('time', type=parse_time, nargs='?')
    pang_parser.set_defaults(func=pang)

    range_parser = subparsers.add_parser('session')
    range_parser.add_argument('activity')
    range_parser.add_argument('time1', type=parse_time, nargs='?', metavar='time')
    range_parser.add_argument('time2', type=parse_time, nargs='?', metavar='time')
    range_parser.add_argument('--frequency', metavar='seconds', type=float, default=1.0)
    range_parser.set_defaults(func=session)

    query_parser = subparsers.add_parser('stats')
    query_parser.add_argument('-a', '--activity', action='append', dest='activities', default=None, metavar='activity')
    query_parser.add_argument('-t', '--timeline', action='append', dest='timelines', default=None, metavar='timeline')
    query_parser.set_defaults(func=stats)

    args = parser.parse_args()

    model = Model()
    args.func(model, args)


