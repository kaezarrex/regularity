#! /usr/bin/env python

from datetime import datetime, timedelta
from itertools import imap, izip
import logging
import math
from operator import itemgetter
import re

from regularity.sparkline import Sparkline
from regularity.stats import EventStats
from regularity.table import Table

def offset_minute(offset):
    '''Parse an offset string to see if it describes a minute offset.

       @param offset : str
           the offset string'''

    match = re.match(r'^([-+])([0-5]?[0-9])$', offset)

    if match:
        sign = match.group(1)
        minutes = int(match.group(2))

        seconds = 60 * minutes

        if '+' == sign:
            return seconds
        return -seconds

    return None

def offset_hour_minute(offset):
    '''Parse an offset string to see if it describes a hour:minute offset.

       @param offset : str
           the offset string'''

    match = re.match(r'^([-+])([0-9]+):([0-5][0-9])$', offset)

    if match:
        sign = match.group(1)
        hours = int(match.group(2))
        minutes = int(match.group(3))

        seconds = 60 * minutes

        if hours:
            hours = int(hours)
            seconds += 3600 * hours

        if '+' == sign:
            return seconds
        return -seconds

    return None

def parse_offset(offset):
    '''Parse a string intended to define an offset from now.

       @param offset : str
           the offset from now'''

    seconds = offset_minute(offset)
    if not seconds:
        seconds = offset_hour_minute(offset)

    if seconds:
        delta_time = timedelta(seconds=seconds)
        return datetime.utcnow() + delta_time

    return None

def parse_time_of_day(time):
    '''Parse a string intended to define a time of day, in 24 hour format

       @time : str
           the time of day'''

    match = re.match(r'(2[0-3]|[0-1][0-9]):([0-5][0-9])$', time)
    if match:
        hours = match.group(1)
        minutes = match.group(2)

        time = datetime.now()
        time = time.replace(microsecond=0)

        if hours is not None:
            hours = int(hours)
            time = time.replace(hour=hours)

        if minutes is not None:
            minutes = int(minutes)
            time = time.replace(minute=minutes)

        time = time.replace(second=0, microsecond=0)

        utc_offset = datetime.utcnow() - datetime.now()
        return time + utc_offset

    return None

def parse_time(time):
    '''Parse a string intended to define a time. It can be specified as an
       offset from now, or a time for TODAY. Offsets are defined as a + or -, 
       then a minute or hour:minute time string. If is no + or -, then the 
       string is parsed as a time. Times are specified as either hour:minute 
       or hour:minute:second strings.

       @param time : str
           a string representing an offset or time of day'''

    time = time.strip()

    _time = parse_offset(time)
    if _time:
        return _time

    _time = parse_time_of_day(time)
    if _time:
        return _time

    raise argparse.ArgumentTypeError('invalid time format')

def pang(model, args):
    '''Log or record a pang - something that happened at a certain point in
       time.
      
       @param model : reularity.model.Model
           the connection to mongoDB
       @param args : argparse.Namespace
           the parsed command line options'''

    timeline = 'bm.pang'
    if args.time:
        time = args.time
    else:
        time = datetime.utcnow()

    model.log(timeline, args.activity, start=args.time, end=args.time)

def session(model, args):
    '''Log or record an activity that happened over a range of time.
      
       @param model : reularity.model.Model
           the connection to mongoDB
       @param args : argparse.Namespace
           the parsed command line options'''

    timeline = 'bm.session'
    now = datetime.utcnow()

    if args.time1:
        if args.time2:
            start = min(args.time1, args.time2)
            end = max(args.time1, args.time2)
        else:
            start = min(now, args.time1)
            end = max(now, args.time1)

        model.log(timeline, args.activity, start=start, end=end)
    else:
        running = True

        model.log(timeline, args.activity, start=now)
        while running:
            try:
                model.update(timeline, args.activity)
                time.sleep(args.frequency)
            except KeyboardInterrupt:
                model.update(timeline, args.activity)
                running = False

def stats(model, args):
    '''Print out statistics for the query defined by the command line
       parameters.

       @param model : reularity.model.Model
           the connection to mongoDB
       @param args : argparse.Namespace
           the parsed command line options'''

    extra_criteria = dict()

    events = model.events(
        name=args.activities,
        timeline=args.timelines
    )

    if args.max_duration:
        duration_td = timedelta(seconds=args.max_duration)
        events = list(e for e in events if e['end'] - e['start'] <= duration_td)

    if not events:
        print 'no events found'
        return

    s = EventStats(*events)
    bins = min(args.bins, len(events))
    bin_counts = s.bin_counts_duration(bins)

    sparkline = Sparkline(*imap(itemgetter(1), bin_counts))
    icolumns = sparkline.icolumns(20)

    output = ((bin_range, bin_count, column) for (bin_range, bin_count), column in izip(bin_counts, icolumns))
    table = Table(*output)
    table.set_column_format(0, '{:0.2f}-{:0.2f}')
    table.set_column_format(1, '{:d}')
    table.set_column_pad_left(1, True)

    print '%d events total' % len(events)
    print 'min duration (seconds):     %0.2f' % s.min_duration()
    print 'max duration (seconds):     %0.2f' % s.max_duration()
    print 'average duration (seconds): %0.2f +/- %0.2f' % (s.mean_duration(), s.std_duration())
    print 'duration breakdown:        ', 
    row_joiner = '\n' + \
          '                            '
    print row_joiner.join(table.iformatted_rows(column_joiner='  ', pad_character=' '))

    print
    

if __name__ == "__main__":

    import argparse
    from itertools import compress
    import time

    import sys

    from regularity.model import Model

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    pang_parser = subparsers.add_parser('pang')
    pang_parser.add_argument('activity')
    pang_parser.add_argument('time', type=parse_time, nargs='?')
    pang_parser.set_defaults(func=pang)

    range_parser = subparsers.add_parser('session')
    range_parser.add_argument('activity')
    range_parser.add_argument('time1', type=parse_time, nargs='?', metavar='time')
    range_parser.add_argument('time2', type=parse_time, nargs='?', metavar='time')
    range_parser.add_argument('--frequency', metavar='seconds', type=float, default=1.0)
    range_parser.set_defaults(func=session)

    stats_parser = subparsers.add_parser('stats')
    stats_parser.add_argument('-a', '--activity', action='append', dest='activities', default=None, metavar='activity')
    stats_parser.add_argument('--bins', type=int, default=5)
    stats_parser.add_argument('--max-duration', type=int, default=None)
    stats_parser.add_argument('-t', '--timeline', action='append', dest='timelines', default=None, metavar='timeline')
    stats_parser.set_defaults(func=stats)

    args = parser.parse_args()

    model = Model()
    args.func(model, args)


