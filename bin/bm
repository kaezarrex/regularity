#! /usr/bin/env python

from datetime import datetime, timedelta
import logging
import re

def parse_offset(offset):
    '''Parse a string intended to define an offset from now.

       @param offset : str
           the offset from now'''

    match = re.match(r'([-+])(([0-9]+):)?([0-5][0-9])(:([0-5][0-9]))?', offset)

    if not match:
        return None
        
    offset = match.group(1)

    pos1 = match.group(3)
    pos2 = match.group(4)
    pos3 = match.group(6)

    times = (pos1, pos2, pos3)
    times = tuple(int(t) for t in times if t is not None)


    if 3 == len(times):
        total_seconds = 3600 * times[0] + 60 * times[1] + times[2]
    elif 2 == len(times):
        total_seconds = 60 * times[0] + times[1]
    else:
        total_seconds = 60 * times[0]


    delta_time = timedelta(seconds=total_seconds)
    if '+' == offset:
        return datetime.utcnow() + delta_time

    return datetime.utcnow() - delta_time

def parse_time_of_day(time):
    '''Parse a string intended to define a time of day, in 24 hour format

       @time : str
           the time of day'''

    match = re.match(r'(2[0-3]|[0-1][0-9]):([0-5][0-9])(:([0-5][0-9]))?', time)

    if not match:
        return None

    hours = match.group(1)
    minutes = match.group(2)
    seconds = match.group(4)

    time = datetime.now()

    if hours is not None:
        hours = int(hours)
        time = time.replace(hour=hours)

    if minutes is not None:
        minutes = int(minutes)
        time = time.replace(minute=minutes)

    if seconds is not None:
        seconds = int(seconds)
        time = time.replace(second=seconds)

    utc_offset = datetime.utcnow() - datetime.now()
    return time + utc_offset

def parse_time(time):
    '''Parse a string intended to define a time. It can be specified as an
       offset from now, or a time for TODAY. Offsets are defined as a + or -, 
       then a minute, minute:second, or hour:minute:second time string. If 
       is no + or -, then the string is parsed as a time. Times are specified 
       as either hour:minute or hour:minute:second strings.

       @param time : str
           a string representing an offset or time of day'''

    time = time.strip()

    start = parse_offset(time)

    if start:
        return start

    return parse_time_of_day(time)

if __name__ == "__main__":

    import argparse
    import time

    import sys

    from regularity.model import Model

    parser = argparse.ArgumentParser()
    parser.add_argument('activity', nargs='+')
    parser.add_argument('-t', '--time')
    parser.add_argument('--debug', action='store_true', default=False)
    parser.add_argument('-f', '--frequency', metavar='seconds', type=float, default=1.0)

    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(
            level=logging.DEBUG
        )
    else:
        logging.basicConfig(
            level=logging.INFO
        )

    model = Model()

    activity = ' '.join(args.activity).lower()

    if args.time:
        other_time = parse_time(args.time)
        now = datetime.utcnow()

        start = min(other_time, now)
        end = max(other_time, now)

        model.log('activity', activity, start=start, end=end)
    else:
        start = datetime.utcnow()

        running = True

        model.log('activity', activity, start=start)
        while running:
            try:
                model.update('activity', activity)
                time.sleep(args.frequency)
            except KeyboardInterrupt:
                model.update('activity', activity)
                running = False

