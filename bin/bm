#! /usr/bin/env python

from datetime import datetime, timedelta
import logging
import re

def offset_minute(offset):
    '''Parse an offset string to see if it describes a minute offset.

       @param offset : str
           the offset string'''

    match = re.match(r'^([-+])([0-5]?[0-9])$', offset)

    if match:
        sign = match.group(1)
        minutes = int(match.group(2))

        seconds = 60 * minutes

        if '+' == sign:
            return seconds
        return -seconds

    return None

def offset_hour_minute(offset):
    '''Parse an offset string to see if it describes a hour:minute offset.

       @param offset : str
           the offset string'''

    match = re.match(r'^([-+])([0-9]+):([0-5][0-9])$', offset)

    if match:
        sign = match.group(1)
        hours = int(match.group(2))
        minutes = int(match.group(3))

        seconds = 60 * minutes

        if hours:
            hours = int(hours)
            seconds += 3600 * hours

        if '+' == sign:
            return seconds
        return -seconds

    return None

def parse_offset(offset):
    '''Parse a string intended to define an offset from now.

       @param offset : str
           the offset from now'''

    seconds = offset_minute(offset)
    if not seconds:
        seconds = offset_hour_minute(offset)

    if seconds:
        delta_time = timedelta(seconds=seconds)
        return datetime.utcnow() + delta_time

    return None

def parse_time_of_day(time):
    '''Parse a string intended to define a time of day, in 24 hour format

       @time : str
           the time of day'''

    match = re.match(r'(2[0-3]|[0-1][0-9]):([0-5][0-9])$', time)
    if match:
        hours = match.group(1)
        minutes = match.group(2)

        time = datetime.now()
        time = time.replace(microsecond=0)

        if hours is not None:
            hours = int(hours)
            time = time.replace(hour=hours)

        if minutes is not None:
            minutes = int(minutes)
            time = time.replace(minute=minutes)

        time = time.replace(second=0, microsecond=0)

        utc_offset = datetime.utcnow() - datetime.now()
        return time + utc_offset

    return None

def parse_time(time):
    '''Parse a string intended to define a time. It can be specified as an
       offset from now, or a time for TODAY. Offsets are defined as a + or -, 
       then a minute or hour:minute time string. If is no + or -, then the 
       string is parsed as a time. Times are specified as either hour:minute 
       or hour:minute:second strings.

       @param time : str
           a string representing an offset or time of day'''

    time = time.strip()

    _time = parse_offset(time)
    if _time:
        return _time

    _time = parse_time_of_day(time)
    if _time:
        return _time

    raise argparse.ArgumentTypeError('invalid time format')

#def parse_activity(activity):
#    '''Parse a list of strings intended to define a time. The list can contain
#       times anywhere, and they will be extracted and return separately.
#
#       @param activity : a list of strings taken from the command line'''
#
#    # parse all the strings to see if they represent times
#    times = tuple(parse_time(s) for s in activity)
#
#    # extract the strings which do not represent times
#    is_activity = tuple(not bool(b) for b in times)
#    activity = compress(activity, is_activity)
#    activity = ' '.join(activity).lower()
#
#    # remove the None times from the times list
#    times = tuple(compress(times, times))
#
#    return activity, times

if __name__ == "__main__":

    import argparse
    from itertools import compress
    import time

    import sys

    from regularity.model import Model

    parser = argparse.ArgumentParser()
    parser.add_argument('activity')
    parser.add_argument('time1', type=parse_time, nargs='?', metavar='time')
    parser.add_argument('time2', type=parse_time, nargs='?', metavar='time')
    parser.add_argument('--debug', action='store_true', default=False)
    parser.add_argument('-f', '--frequency', metavar='seconds', type=float, default=1.0)

    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(
            level=logging.DEBUG
        )
    else:
        logging.basicConfig(
            level=logging.INFO
        )

    model = Model()

    now = datetime.utcnow()
    if args.time1:
        if args.time2:
            start = min(args.time1, args.time2)
            end = max(args.time1, args.time2)
        else:
            start = min(now, args.time1)
            end = max(now, args.time1)

        model.log('activity', args.activity, start=start, end=end)
    else:
        running = True

        model.log('activity', args.activity, start=now)
        while running:
            try:
                model.update('activity', args.activity)
                time.sleep(args.frequency)
            except KeyboardInterrupt:
                model.update('activity', args.activity)
                running = False

