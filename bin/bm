#! /usr/bin/env python

from datetime import datetime, timedelta
import logging
import re

def parse_offset(offset):
    '''Parse a string intended to define an offset from now.

       @param offset : str
           the offset from now'''

    match = re.match(r'([-+])(([0-9]+):)?([0-5][0-9])(:([0-5][0-9]))?$', offset)

    if not match:
        return None
        
    offset = match.group(1)

    pos1 = match.group(3)
    pos2 = match.group(4)
    pos3 = match.group(6)

    times = (pos1, pos2, pos3)
    times = tuple(int(t) for t in times if t is not None)


    if 3 == len(times):
        total_seconds = 3600 * times[0] + 60 * times[1] + times[2]
    elif 2 == len(times):
        total_seconds = 60 * times[0] + times[1]
    else:
        total_seconds = 60 * times[0]


    delta_time = timedelta(seconds=total_seconds)
    if '+' == offset:
        return datetime.utcnow() + delta_time

    return datetime.utcnow() - delta_time

def parse_time_of_day(time):
    '''Parse a string intended to define a time of day, in 24 hour format

       @time : str
           the time of day'''

    match = re.match(r'(2[0-3]|[0-1][0-9]):([0-5][0-9])(:([0-5][0-9]))?$', time)
    if not match:
        return None

    hours = match.group(1)
    minutes = match.group(2)
    seconds = match.group(4)

    time = datetime.now()

    if hours is not None:
        hours = int(hours)
        time = time.replace(hour=hours)

    if minutes is not None:
        minutes = int(minutes)
        time = time.replace(minute=minutes)

    if seconds is not None:
        seconds = int(seconds)
        time = time.replace(second=seconds)
    else:
        time = time.replace(second=0)

    time = time.replace(microsecond=0)

    utc_offset = datetime.utcnow() - datetime.now()
    return time + utc_offset

def parse_time(time):
    '''Parse a string intended to define a time. It can be specified as an
       offset from now, or a time for TODAY. Offsets are defined as a + or -, 
       then a minute, minute:second, or hour:minute:second time string. If 
       is no + or -, then the string is parsed as a time. Times are specified 
       as either hour:minute or hour:minute:second strings.

       @param time : str
           a string representing an offset or time of day'''

    time = time.strip()

    _time = parse_offset(time)
    if _time:
        return _time

    _time = parse_time_of_day(time)
    if _time:
        return _time

    return None

def parse_activity(activity):
    '''Parse a list of strings intended to define a time. The list can contain
       times anywhere, and they will be extracted and return separately.

       @param activity : a list of strings taken from the command line'''

    # parse all the strings to see if they represent times
    times = tuple(parse_time(s) for s in activity)

    # extract the strings which do not represent times
    is_activity = tuple(not bool(b) for b in times)
    activity = compress(activity, is_activity)
    activity = ' '.join(activity).lower()

    # remove the None times from the times list
    times = tuple(compress(times, times))

    return activity, times

if __name__ == "__main__":

    import argparse
    from itertools import compress
    import time

    import sys

    from regularity.model import Model

    parser = argparse.ArgumentParser()
    parser.add_argument('activity', nargs='+')
    parser.add_argument('--debug', action='store_true', default=False)
    parser.add_argument('-f', '--frequency', metavar='seconds', type=float, default=1.0)

    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(
            level=logging.DEBUG
        )
    else:
        logging.basicConfig(
            level=logging.INFO
        )

    model = Model()

    activity, times = parse_activity(args.activity)

    if len(times) > 2:
        print 'at most two times can be supplied'
        sys.exit(1)

    now = datetime.utcnow()
    if times:
        
        if 1 == len(times):
            start = min(now, *times)
            end = max(now, *times)
        else:
            start = min(*times)
            end = max(*times)

        model.log('activity', activity, start=start, end=end)
    else:
        running = True

        model.log('activity', activity, start=now)
        while running:
            try:
                model.update('activity', activity)
                time.sleep(args.frequency)
            except KeyboardInterrupt:
                model.update('activity', activity)
                running = False

